// Code generated by protoc-gen-go.
// source: gossel.proto
// DO NOT EDIT!

/*
Package gosselproto is a generated protocol buffer package.

It is generated from these files:
	gossel.proto

It has these top-level messages:
	User
	Msg
	Irc
	Control
	Auth
	Subscribe
	Network
	Identity
*/
package gosselproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type User struct {
	User     string `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Msg struct {
	// Types that are valid to be assigned to MessageType:
	//	*Msg_Network
	//	*Msg_Control
	//	*Msg_Subscribe
	//	*Msg_Irc
	//	*Msg_Auth
	MessageType isMsg_MessageType `protobuf_oneof:"message_type"`
}

func (m *Msg) Reset()                    { *m = Msg{} }
func (m *Msg) String() string            { return proto.CompactTextString(m) }
func (*Msg) ProtoMessage()               {}
func (*Msg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isMsg_MessageType interface {
	isMsg_MessageType()
}

type Msg_Network struct {
	Network *Network `protobuf:"bytes,1,opt,name=network,oneof"`
}
type Msg_Control struct {
	Control *Control `protobuf:"bytes,2,opt,name=control,oneof"`
}
type Msg_Subscribe struct {
	Subscribe *Subscribe `protobuf:"bytes,3,opt,name=subscribe,oneof"`
}
type Msg_Irc struct {
	Irc *Irc `protobuf:"bytes,4,opt,name=irc,oneof"`
}
type Msg_Auth struct {
	Auth *Auth `protobuf:"bytes,5,opt,name=auth,oneof"`
}

func (*Msg_Network) isMsg_MessageType()   {}
func (*Msg_Control) isMsg_MessageType()   {}
func (*Msg_Subscribe) isMsg_MessageType() {}
func (*Msg_Irc) isMsg_MessageType()       {}
func (*Msg_Auth) isMsg_MessageType()      {}

func (m *Msg) GetMessageType() isMsg_MessageType {
	if m != nil {
		return m.MessageType
	}
	return nil
}

func (m *Msg) GetNetwork() *Network {
	if x, ok := m.GetMessageType().(*Msg_Network); ok {
		return x.Network
	}
	return nil
}

func (m *Msg) GetControl() *Control {
	if x, ok := m.GetMessageType().(*Msg_Control); ok {
		return x.Control
	}
	return nil
}

func (m *Msg) GetSubscribe() *Subscribe {
	if x, ok := m.GetMessageType().(*Msg_Subscribe); ok {
		return x.Subscribe
	}
	return nil
}

func (m *Msg) GetIrc() *Irc {
	if x, ok := m.GetMessageType().(*Msg_Irc); ok {
		return x.Irc
	}
	return nil
}

func (m *Msg) GetAuth() *Auth {
	if x, ok := m.GetMessageType().(*Msg_Auth); ok {
		return x.Auth
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Msg) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _Msg_OneofMarshaler, _Msg_OneofUnmarshaler, []interface{}{
		(*Msg_Network)(nil),
		(*Msg_Control)(nil),
		(*Msg_Subscribe)(nil),
		(*Msg_Irc)(nil),
		(*Msg_Auth)(nil),
	}
}

func _Msg_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Msg)
	// message_type
	switch x := m.MessageType.(type) {
	case *Msg_Network:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Network); err != nil {
			return err
		}
	case *Msg_Control:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Control); err != nil {
			return err
		}
	case *Msg_Subscribe:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Subscribe); err != nil {
			return err
		}
	case *Msg_Irc:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Irc); err != nil {
			return err
		}
	case *Msg_Auth:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Auth); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Msg.MessageType has unexpected type %T", x)
	}
	return nil
}

func _Msg_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Msg)
	switch tag {
	case 1: // message_type.network
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Network)
		err := b.DecodeMessage(msg)
		m.MessageType = &Msg_Network{msg}
		return true, err
	case 2: // message_type.control
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Control)
		err := b.DecodeMessage(msg)
		m.MessageType = &Msg_Control{msg}
		return true, err
	case 3: // message_type.subscribe
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Subscribe)
		err := b.DecodeMessage(msg)
		m.MessageType = &Msg_Subscribe{msg}
		return true, err
	case 4: // message_type.irc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Irc)
		err := b.DecodeMessage(msg)
		m.MessageType = &Msg_Irc{msg}
		return true, err
	case 5: // message_type.auth
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Auth)
		err := b.DecodeMessage(msg)
		m.MessageType = &Msg_Auth{msg}
		return true, err
	default:
		return false, nil
	}
}

type Irc struct {
	Command  string      `protobuf:"bytes,1,opt,name=command" json:"command,omitempty"`
	Prefix   *Irc_Prefix `protobuf:"bytes,2,opt,name=prefix" json:"prefix,omitempty"`
	Params   []string    `protobuf:"bytes,3,rep,name=params" json:"params,omitempty"`
	Trailing string      `protobuf:"bytes,4,opt,name=trailing" json:"trailing,omitempty"`
	Network  string      `protobuf:"bytes,5,opt,name=network" json:"network,omitempty"`
}

func (m *Irc) Reset()                    { *m = Irc{} }
func (m *Irc) String() string            { return proto.CompactTextString(m) }
func (*Irc) ProtoMessage()               {}
func (*Irc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Irc) GetPrefix() *Irc_Prefix {
	if m != nil {
		return m.Prefix
	}
	return nil
}

type Irc_Prefix struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	User string `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Host string `protobuf:"bytes,3,opt,name=host" json:"host,omitempty"`
}

func (m *Irc_Prefix) Reset()                    { *m = Irc_Prefix{} }
func (m *Irc_Prefix) String() string            { return proto.CompactTextString(m) }
func (*Irc_Prefix) ProtoMessage()               {}
func (*Irc_Prefix) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type Control struct {
}

func (m *Control) Reset()                    { *m = Control{} }
func (m *Control) String() string            { return proto.CompactTextString(m) }
func (*Control) ProtoMessage()               {}
func (*Control) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type Auth struct {
	Username string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
}

func (m *Auth) Reset()                    { *m = Auth{} }
func (m *Auth) String() string            { return proto.CompactTextString(m) }
func (*Auth) ProtoMessage()               {}
func (*Auth) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type Subscribe struct {
	Network     string `protobuf:"bytes,1,opt,name=network" json:"network,omitempty"`
	Channel     string `protobuf:"bytes,2,opt,name=channel" json:"channel,omitempty"`
	Unsubscribe bool   `protobuf:"varint,3,opt,name=unsubscribe" json:"unsubscribe,omitempty"`
}

func (m *Subscribe) Reset()                    { *m = Subscribe{} }
func (m *Subscribe) String() string            { return proto.CompactTextString(m) }
func (*Subscribe) ProtoMessage()               {}
func (*Subscribe) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type Network struct {
	Name     string    `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Network  string    `protobuf:"bytes,2,opt,name=network" json:"network,omitempty"`
	Password string    `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
	Tls      bool      `protobuf:"varint,4,opt,name=tls" json:"tls,omitempty"`
	Identity *Identity `protobuf:"bytes,5,opt,name=identity" json:"identity,omitempty"`
	Add      bool      `protobuf:"varint,6,opt,name=add" json:"add,omitempty"`
}

func (m *Network) Reset()                    { *m = Network{} }
func (m *Network) String() string            { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()               {}
func (*Network) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Network) GetIdentity() *Identity {
	if m != nil {
		return m.Identity
	}
	return nil
}

type Identity struct {
	Username string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	Realname string `protobuf:"bytes,2,opt,name=realname" json:"realname,omitempty"`
	Awaymsg  string `protobuf:"bytes,3,opt,name=awaymsg" json:"awaymsg,omitempty"`
}

func (m *Identity) Reset()                    { *m = Identity{} }
func (m *Identity) String() string            { return proto.CompactTextString(m) }
func (*Identity) ProtoMessage()               {}
func (*Identity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func init() {
	proto.RegisterType((*User)(nil), "gosselproto.User")
	proto.RegisterType((*Msg)(nil), "gosselproto.Msg")
	proto.RegisterType((*Irc)(nil), "gosselproto.Irc")
	proto.RegisterType((*Irc_Prefix)(nil), "gosselproto.Irc.Prefix")
	proto.RegisterType((*Control)(nil), "gosselproto.Control")
	proto.RegisterType((*Auth)(nil), "gosselproto.Auth")
	proto.RegisterType((*Subscribe)(nil), "gosselproto.Subscribe")
	proto.RegisterType((*Network)(nil), "gosselproto.Network")
	proto.RegisterType((*Identity)(nil), "gosselproto.Identity")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Gosselcore service

type GosselcoreClient interface {
	Connect(ctx context.Context, opts ...grpc.CallOption) (Gosselcore_ConnectClient, error)
}

type gosselcoreClient struct {
	cc *grpc.ClientConn
}

func NewGosselcoreClient(cc *grpc.ClientConn) GosselcoreClient {
	return &gosselcoreClient{cc}
}

func (c *gosselcoreClient) Connect(ctx context.Context, opts ...grpc.CallOption) (Gosselcore_ConnectClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Gosselcore_serviceDesc.Streams[0], c.cc, "/gosselproto.gosselcore/Connect", opts...)
	if err != nil {
		return nil, err
	}
	x := &gosselcoreConnectClient{stream}
	return x, nil
}

type Gosselcore_ConnectClient interface {
	Send(*Msg) error
	Recv() (*Msg, error)
	grpc.ClientStream
}

type gosselcoreConnectClient struct {
	grpc.ClientStream
}

func (x *gosselcoreConnectClient) Send(m *Msg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gosselcoreConnectClient) Recv() (*Msg, error) {
	m := new(Msg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Gosselcore service

type GosselcoreServer interface {
	Connect(Gosselcore_ConnectServer) error
}

func RegisterGosselcoreServer(s *grpc.Server, srv GosselcoreServer) {
	s.RegisterService(&_Gosselcore_serviceDesc, srv)
}

func _Gosselcore_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GosselcoreServer).Connect(&gosselcoreConnectServer{stream})
}

type Gosselcore_ConnectServer interface {
	Send(*Msg) error
	Recv() (*Msg, error)
	grpc.ServerStream
}

type gosselcoreConnectServer struct {
	grpc.ServerStream
}

func (x *gosselcoreConnectServer) Send(m *Msg) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gosselcoreConnectServer) Recv() (*Msg, error) {
	m := new(Msg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Gosselcore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gosselproto.gosselcore",
	HandlerType: (*GosselcoreServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Connect",
			Handler:       _Gosselcore_Connect_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}

var fileDescriptor0 = []byte{
	// 438 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x92, 0xcd, 0xae, 0xd3, 0x30,
	0x10, 0x85, 0x9b, 0x1f, 0xd2, 0x64, 0x52, 0x5d, 0x2e, 0xe6, 0x2f, 0xba, 0x1b, 0x20, 0x0b, 0x6e,
	0x05, 0x52, 0x84, 0xda, 0x07, 0x40, 0x2d, 0x9b, 0xb2, 0x00, 0x21, 0x21, 0xd6, 0xc8, 0x4d, 0x4c,
	0x1a, 0x91, 0xd8, 0x91, 0xed, 0xa8, 0x74, 0xc1, 0xeb, 0xf0, 0x4c, 0x3c, 0x0e, 0xb6, 0xe3, 0x54,
	0x49, 0xcb, 0x2a, 0xb2, 0xcf, 0xe7, 0x99, 0x33, 0x67, 0x02, 0x8b, 0x92, 0x09, 0x41, 0xea, 0xac,
	0xe5, 0x4c, 0x32, 0x14, 0xf7, 0x27, 0x73, 0x48, 0x5f, 0x83, 0xff, 0x4d, 0x10, 0x8e, 0x16, 0xe0,
	0x77, 0xea, 0x9b, 0x38, 0x2f, 0x9d, 0x65, 0x84, 0x6e, 0x21, 0x6c, 0xb1, 0x10, 0x47, 0xc6, 0x8b,
	0xc4, 0xd5, 0x37, 0xe9, 0x5f, 0x07, 0xbc, 0x4f, 0xa2, 0x44, 0xf7, 0x30, 0xa7, 0x44, 0x2a, 0xe1,
	0xa7, 0x41, 0xe3, 0xd5, 0x93, 0x6c, 0x54, 0x2e, 0xfb, 0xdc, 0x6b, 0xbb, 0x99, 0x06, 0x73, 0x46,
	0x25, 0x67, 0xb5, 0xa9, 0x70, 0x09, 0x7e, 0xe8, 0x35, 0x05, 0xbe, 0x85, 0x48, 0x74, 0x7b, 0x91,
	0xf3, 0x6a, 0x4f, 0x12, 0xcf, 0xa0, 0xcf, 0x26, 0xe8, 0xd7, 0x41, 0x55, 0xf0, 0x0b, 0xf0, 0x2a,
	0x9e, 0x27, 0xbe, 0xc1, 0x6e, 0x27, 0xd8, 0x47, 0x9e, 0x2b, 0xe0, 0x15, 0xf8, 0xb8, 0x93, 0x87,
	0xe4, 0x81, 0x21, 0x1e, 0x4d, 0x88, 0x8d, 0x12, 0x76, 0xb3, 0xed, 0x0d, 0x2c, 0x1a, 0x22, 0x04,
	0x2e, 0xc9, 0x77, 0x79, 0x6a, 0x49, 0xfa, 0x47, 0x8d, 0xa6, 0x1e, 0xa3, 0x87, 0xda, 0x71, 0xd3,
	0x60, 0x5a, 0xd8, 0x14, 0xee, 0x21, 0x68, 0x39, 0xf9, 0x51, 0xfd, 0xb2, 0x13, 0x3c, 0xbf, 0xec,
	0x97, 0x7d, 0x31, 0x32, 0xba, 0x51, 0x20, 0xe6, 0xb8, 0x11, 0xca, 0xbf, 0xd7, 0xc7, 0x27, 0x39,
	0xae, 0xea, 0x8a, 0x96, 0xc6, 0x6a, 0xa4, 0x6b, 0x0f, 0xb1, 0x69, 0x67, 0xd1, 0xdd, 0x0a, 0x02,
	0xfb, 0x58, 0x25, 0x4f, 0x71, 0x43, 0x6c, 0xcf, 0x61, 0x0f, 0xee, 0x70, 0x3a, 0x30, 0x21, 0x4d,
	0x2c, 0x51, 0x1a, 0xc1, 0xdc, 0xc6, 0x96, 0xbe, 0x01, 0x5f, 0x4f, 0xa3, 0x3b, 0x69, 0x7c, 0x54,
	0xe0, 0x7a, 0x75, 0x5b, 0x88, 0xce, 0x11, 0x8e, 0x8d, 0x38, 0x83, 0xb3, 0xfc, 0x80, 0x29, 0x25,
	0xb5, 0xed, 0xf9, 0x18, 0xe2, 0x8e, 0x4e, 0x37, 0x12, 0xa6, 0xbf, 0x61, 0x6e, 0x57, 0x7b, 0xe1,
	0x77, 0x54, 0xcf, 0xbd, 0xea, 0x6f, 0x6c, 0xa3, 0x18, 0x3c, 0x59, 0x0b, 0x13, 0x44, 0xa8, 0x32,
	0x0d, 0xab, 0x82, 0x50, 0x59, 0xc9, 0x93, 0xdd, 0xd1, 0xd3, 0x69, 0xaa, 0x56, 0xd4, 0xaf, 0x70,
	0x51, 0x24, 0x81, 0x69, 0xff, 0x1e, 0xc2, 0xb3, 0xf0, 0xdf, 0x91, 0x39, 0xc1, 0xb5, 0xb9, 0x71,
	0x07, 0x57, 0xf8, 0x88, 0x4f, 0x8d, 0x28, 0x7b, 0x0f, 0xab, 0x0d, 0x40, 0xdf, 0x25, 0x67, 0x9c,
	0xa0, 0xb5, 0x09, 0x92, 0x92, 0x5c, 0xa2, 0xe9, 0x3f, 0xa4, 0xfe, 0xf0, 0xbb, 0xab, 0x9b, 0x74,
	0xb6, 0x74, 0xde, 0x39, 0xfb, 0xc0, 0x5c, 0xac, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x09, 0x17,
	0x15, 0x53, 0x4d, 0x03, 0x00, 0x00,
}
